# Алгоритми сортиране.

- Сложност: Функция по големината на входа (N)

## Пример:

- При търсене в масив - големината на входа е големината на масива
- При проверка число дали е просто - големината на входа е числото.
- При анализа на алгоритми НЕ се интересуваме от точната функция! 


# Bubble sort 

- Работи чрез повтарящо се сравняване на съседни елементи и разменяне на местата 
им, ако са в грешен ред.
 
## Сложност: 

- Най-лош случай: O(n^2) 

- Най-добър случай: O(n) (когато масивът вече е сортиран). 

## Предимства: 

- Лесен за имплементиране. 

## Недостатъци: 

- Неефективен за големи набори от данни. 

# SelectionSort 

- Намира минималния елемент в масива и го поставя в началото. Повтаря процеса за 
останалите елементи.
 
## Сложност: 

- Най-лош случай: O(n^2) 

-  Най-добър случай: O(n^2) (няма оптимизация за сортиран масив). 

## Предимства: 

- Не използва допълнителна памет. 

## Недостатъци: 

- По-бавен от други алгоритми. 

# Insertion Sort 

## Описание: 

- Взема един елемент и го вмъква в сортираната част на масива. 

## Сложност: 

- Най-лош случай:O(n^2) 

- Най-добър случай: O(n) (когато масивът е почти сортиран).
 
## Предимства: 

-  Ефективен за малки и почти сортирани масиви. 

## Недостатъци: 

- Не е подходящ за големи данни.

# Двоично търсене (Binary Search) 

-  Описание: Използва разделяй-и-владеи стратегия. Работи само с предварително 
сортирани масиви. На всяка итерация разделя масива на две половини и сравнява 
средния елемент с търсения. Ако търсеният елемент е по-малък, търсенето 
продължава в лявата половина, иначе в дясната. 

## Сложност: 

- Най-лош случай: O(log n) 

- Най-добър случай: O(1)— ако елементът е средата. 

## Предимства: 

- Много по-бърз от линейното търсене за големи структури.
 
## Недостатъци: 

- Изисква сортиран масив. 

- По-сложен за имплементиране.

Задачи:
## Задачи 
### Задачи са търсене

**1.** Да се напише функция, която приема число и матрица, чиито редове и колони са сортирани в растящ ред. Функцията да връща индексите на реда и колоната, на която се намира числото (реализира се чрез двоично търсене).

**Пример:**

Вход:
```c++
7
1 2 3 
4 5 6
7 8 9
```
Изход:
```c++
2 0
```

**2.** Да се напише функция, която приема сортиран масив   от цели числа (в който може да има повторения) и цяло число и връща индекса, на който трябва да се вмъкне числото.

**Пример:**

Вход:
```c++
1 2 5 6 7 8 9
4
```

Изход:
```c++
2
```
**3.** Да се напише функция, която приема масив от цели числа и връща дължината на най-дългата редица от еднакви числа.

**Пример:**

Вход:

```c++
[3 3 2 2 2 5 2 2 3 3 3]
```

Изход:

```c++
3
```
### Задачи за сортиране
**4.** Да се напише функция, която приема масив от цели неотрицателни числа и връща първото липсващо число.

**Пример:**

Вход:
```c++
0 6 3 2 1
```

Изход:
```c++
4
```

**5.** Да се напише функция, която приема масив от неповтарящи се цели числа и цяло число **k** и връща **k**-тия по големина елемент (не е нужно да се сортира целия масив).

**Пример:**

Вход:
```c++
[39, 4, 6, 1, 2, 66, 33]
3
```
Изход:
```c++
33
```

**6.** Даден е масив от цели числа (без повторение) - цени на бонбони. Разполагаме с **k** лева. Да се напише функция, която приема масива и **k** и връща колко най-много бонбона можем да закупим.

**Пример:**

Вход:
```c++
[39, 4, 6, 1, 2, 66, 33]
40
```
Изход:
```c++
4
```

**7.** Да се напише функция, която приема масив от цели числа и го сортира така, че в лявата част да са четните числа, сортирани в нарастващ ред, а в дясната - нечетните в намаляващ.

**Пример:**

Вход:
```c++
1 2 3 6 5 4
```
Изход:
```c++
2 4 6 5 3 1
```
**8.** Иванчо и Марийка решили да вдигнат купон. Марийка викнала само момичета, а Иванчо - само момчета. Тъй като момчетата и момичетата били равен брой, двамата решили да ги подредят по височина и да ги групират по двойки. Да се напише функция, която приема масив от височините на гостите и ги принтира по двойки (момчетата са с нечетна височина, а момичетата - с четна).

**Пример:**

Вход:
```c++
[201, 186, 180, 186, 183, 185, 170, 161, 194, 197, 164, 175, 161, 186]
```
Изход:
```c++
161 164
161 170
175 180
183 186
185 186
197 186
201 194
```
### **9.** Да се напише функция, която приема 3 масива от цели числа - arr1, arr2 и result (който е празен), като arr1 и arr2 са сортирани във възходящ ред. В края на функцията result трябва представлява обединение на 2-та масива и е сортиран във възходящ ред.

**Пример:**
```c++
[1, 5, 7, 8]
[2, 3, 9]
```
```c++
[1, 2, 3, 5, 7, 8, 9]
```

### **10.** Да се напишат функции, които приемат 3 масива от цели числа - **arr1**, **arr2** и **result** (който е празен) и пълнят третия съответно с обединението на **arr1** и **arr2**. **result** да е сортиран във възходящ ред.
Вход:

```
[2 4 1 7 8]
[1 2 3 5]
```

Изход:

```
[ 1 2 3 4 5 7 8 ]

```

### **11.** Да се напише функция, която приема 3 масива от цели числа - **arr1**, **arr2** и **result** (който е празен). В края на функцията **result** представлява сечението на 2-та масива и е сортиран във възходящ ред.

**Пример:**

Вход:

```
[2 4 1 3 7 8]
[1 2 3 5]
```

Изход:

```
[ 1 2 3 ]
```

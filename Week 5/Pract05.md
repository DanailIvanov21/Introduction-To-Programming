## Масиви
В програмния език C/C++ могат да бъдат дефинирани и обработвани едномерни и многомерни масиви.

### Масивът е структура, която се асоциира с едно име, един начален адрес, един тип и множество от стойности.

## Едномерни масиви:
- Едномерният масив е списък от еднотипни променливи, които се съхраняват в последователни клетки от паметта.
  
- Всяка отделна променлива от масива се нарича елемент на масива и достъпът до тях е чрез името на масива и индекс (или адрес).
  
- Индексите на масива в С/С++ програмите започват от нула.

### Обща форма за дефиниране на масив:

```c++
тип име_на_масив [размер1] [размер2] […] ;
```

Използват се всички типове на С/С++ за дефиниране на типа на елементите, включително и масив от структури или от масиви. Името се съставя по правилата за идентификатор, т.е. започва с буква или знак ‘_’, следвани от букви и/или цифри. Размерът е израз от цял тип, който може да има само положителни стойности. Не може да бъде променлива, но може да бъде предварително дефинирана константа и определя максималния брой елементи при дефиниране на масива.

```c++
Пример: int masiv1[100], alpha[2*15+56];

```
- Името на масива играе роля на указател към началния адрес на масива или казано иначе, към нулевия елемент на масива.

### Един масив може да се инициализира още при дефинирането му.

```c++
Пример: int m[6] = {3,5,9,1,0,12}; // m[0]=3, m[1]=5,......,m[5]=12
```

Ако явно се инициализират по-малко елементи на масива, то останалите се инициализират неявно с 0.

### Общата форма за инициализация на едномерен масив е:
```c++
тип име_на_масив [размер] = {списък от стойности};
```

- Списъкът от стойности представлява последователност от константи разделени със запетаи.

- Масивите се обработват поелементно, най-често чрез оператор за цикъл. Най-удобен оператор за цикъл при работа с масиви е операторът for. Освен въвеждането и извеждането на елементи на масив, едни от най-типичните обработки са за търсене, пренареждане и сортиране на масиви.

- В масивите имаме константен достъп до всеки един елемент. Достъпът става посредством индекси. Индексацията започва от 0.

### Пример:
  ```c++
 int arr[] = {1, 6, 100, 23, 48}
 arr[3] = 12; //Присвоява на елемента на индекс 3 стойността 44.
 				       // [1,6,100,23,48]
 cout << arr[2]; // Отпечатва на стандартния изход елементът на индекс 2 (100)
 cout << arr[0]; // 1
 cout << arr[5]; // 48
```

### Подаване на масиви във функции

- Масивите се подават във функциите по адрес! Т.е промените, които се правят върху масива във функцията, ще се отразят върху подадения като параметър масив!

```c++
void funct(int arr[], size_t len);
void funct2(const int arr[], size_t len)
```



## Примери
**1.** Какво ще върне следната функция?
```c++
#include <iostream>
double f()
{
     double num1 = 4;
     double num2 = 4 / 7;
     return (num2-- = ++num1 + 2);
}
```



# Задачи, максималният размер да е 1024

**1.** Да се напише функция, която приема масив от цели числа и размера му, и връща дали е сортиран.

Вход:
```c++
[5, 7, 4, 9]
```
Изход:
```c++
false
```
Вход:
```c++
[1, 2, 3, 4]
```

Изход:
```c++
true
```

**2.**  Да се напише функция, която приема масив от цели числа и размера му, и връща средната стойност на елементите му и числото, което е най-близо до тази средна стойност.

**Пример:**

Вход:
```c++
[5 7 4 9]
```

Изход:
```c++
6.25
7
```
**3.** Напишете програма, която въвежда от клавиатурата цяло число от 2 до 30. Въведете толкова елементи в масива, колкото е въведеното от клавиатурата число .
Намерете максималния и минималния елемент на масива, разменете местата им и изведете масива.

```c++
Вход: 7
4, 6, 87, 354, 6, 73, 11

Изход: 354 , 6, 87, 4 , 6, 73, 11
```


**4.** Напишете функция, която приема масив от цели числа, размера му и число N, и обръща първите N елемента на масива.

Вход:
```c++
[1, -4, 4, -5, -9, 2, 10]
4
```

Изход:
```c++
[-5, 4, -4, 1, -9, 2, 10]
```

**5.** Напишете програма, която въвежда от клавиатурата цяло число от 2 до 25. Въведете толкова елементи в масива, колкото е въведеното от клавиатурата число.
Изведете на екрана всички четни числа от масива. Ако няма четни числа изведете подходящо съобщение.
```c++
Вход: 5
2, 5, 25, 17, 10

Изход: 2, 10

Вход: 5
3, 5, 25, 17, 5

Изход: No even numbers
```

**6.**  Напишете функция, която приема масив от цели числа и индекс и премахва числото, което се намира на този индекс.

Вход:

```
[33 1 23 8 54 5 1 6] 3
```

Изход:

```
[33 1 23 54 5 1 6]
```


**7.** Да се напише функция, която приема масив от цели числа и размера му и връща дали е симетричен.

Вход:

```
[1 2 3 2 1]
```

Изход:

```
yes
```

Вход:

```
[1 2 3 4 1]
```

Изход:

```
no
```

**8.** Да се напише функция, която приема масив от цели числа и връща дължината на най-дългата редица от еднакви числа.

**Пример:**

Вход:

```c++
[3 3 2 2 2 5 2 2 3 3 3]
```

Изход:

```c++
3
```
**9.** Напишете функция, която приема масив от цели числа и филтрира отрицателните елементи от масива, като ги премахва.

**Пример:**
```c++
[1, -4, 4, -5, -9, 2, 10]
```
```c++
[1, 4, 2, 10]
```


**10.** Напишете функция, която приема два масива от цели числа и размерите им, и проверява дали вторият масив е подмасив на първия.

Вход:
```c++
[1, 4, 4, 0, 4, 2]
[4, 0, 4]
```

Изход:
```c++
true
```

Вход:
```c++
[1, 4, 9, 8, 4, 2]
[4, 9, 2]
```

Изход:
```c++
false
```
**11.** Напишете програма, която въвежда от клавиатурата цяло число от 2 до 30. Въведете толкова елементи в масива, колкото е въведеното от клавиатурата число. 
Да се намери и изведе броя на числата от масива, чийто сбор от цифрите им е двуцифрено число. Ако няма такива изведете подходящо съобщение.
```c++
Вход: 5
14 67 3 89 54

Изход: 2
```

**12.** Напишете функция, която приема 2 масива, съставени само от цифрите от 0 до 9, с еднаква дължина. Функцията да връща дали вторият масив е пермутация на първия.

Вход:
```c++
[1, 4, 4, 0, 4, 2]
[0, 4, 4, 4, 1, 2]
```

Изход:
```c++
true
```

Вход:
```c++
[1, 4, 9, 8, 4, 2]
[9, 6, 7, 4, 5, 2]
```

Изход:
```c++
false
```

**13.** Да се напише функция, която приема масив и връща дали е конкатенация на два масива, които са палиндроми.

```c++
Вход: [1 2 3 2 1 4 5 5 4], Изход: true

Вход: [1 2 3 4 5], Изход: false

Вход: [1 2 3 2 1], Изход: true
```

**14.** Въвежда се число N (N <= 1000) и N цели числа (елементи на масив). Да се отпечатат броя на инверсиите в масива.

// Инверсия ще наричаме двойка индекси (i,j), където i < j и arr[i] > arr[j]

```c++
Вход: 6 5 4 3 2 10 Изход: 15 //в масива [5 4 3 2 1 0] има 15 инверсии.

Вход: 5 10 11 12 13 14 15, Изход: 0

```

 **15.** Ще казваме, че поредица от числа е трион, ако всяко число в нея е едновременно по- голямо или равно на двата си съседа или едновременно по- малко или равно на тях.
За първия и последния елемент имаме само по един съсед.
Напишете функция, която приема масив от цели числа и ги пренарежда така, че да образуват поредица трион.

```c++
Вход: 1 5 1 0 3, Изход: 1 5 0 3 1
Вход: 10 -10 -22 11 18, Изход: 10 -22 11 -10 18
```

**16.** Да се напише функция, която проверява дали в подаден масив стойността на най-големия елемент е равна на сумата от стойностите на останалите елементи.
```c++
Вход: 8,9,17,53,12,7
Изход: Yes
```


**17.** Да се напише програма, която на първия ред приема цяло число N, което е големина на масив
и после N на брой числа, които трябва да се сложат в масива. Програмата приема число,
което трябва да бъде изтрито от масива. Трябва да изтриете всички срещания на числото от
масива и да го изкарате на екрана . В масива не трябва да има празни елементи или дупките
да се запълват със 'специални' числа.
```c++
Вход:
8 4 3 2 4 5 6 4 9 4
Изход:
3 2 5 6 9
```

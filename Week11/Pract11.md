## Динамична памет - втора част

## Динамично заделени двумерни масиви

1. Създаване

 ```c++
   int** dynamicMatrix = new int*[rowsCount];
for (size_t i = 0; i < rowsCount; i++)
{
    dynamicMatrix[i] = new int[colsCount];
}
```

При rowsCount = 4 и colsCount = 5, резултатът ще е следният:


<img width="581" height="401" alt="Screenshot (1431)" src="https://github.com/user-attachments/assets/7fd91ac1-9dfd-496b-b6f0-8b4b9bc2e700" />


2. Изтриване

 ```c++
for (size_t i = 0; i < rowsCount; i++)
{
    delete[] dynamicMatrix[i];
}
delete[] dynamicMatrix;
 ```


## Задачи

**1.** Да се напише функция, която приема матрица и индекс **i** и връща нова матрица, за която е заделено точно количество памет, в която липсва **i**-тия ред.

**Пример:**

Вход:
```c++
1 2 3 
4 5 6
7 8 9
1
```
Изход:
```c++
1 2 3 
7 8 9
```

**2.** Да се напише функция, която приема матрица и индекс **i** и връща нова матрица, за която е заделено точно количество памет, в която липсва **i**-тия стълб.

**Пример:**

Вход:
```c++
1 2 3 
4 5 6
7 8 9
1
```

Изход:
```c++
1 3 
4 6
7 9
```

**3.** Да се напише функция, която матрица и връща нова матрица, за която е заделено точно количество памет, в която е транспонирана подадената.

**Пример:**

Вход:
```c++
1 3 
4 6
7 9
```
Изход:
```c++
1 4 7
3 6 9

```
**4.** Дадена е двумерна матрица nxm от цели числа. Да се напише следната функция:

- Ако броят на колоните е по-голям от броя на редовете, функцията връща два нови динамично заделени масива, като единият е съставен от нечетните колони, а другият - от четните.
  
- Ако броят на редовете е по-голям или равен от/на броя на колоните, функцията връща два нови динамично заделени масива, като единият е съставен от нечетните редове, а другият - от четните.

**Пример:**

Вход:
```c++
5 6
```
https://camo.githubusercontent.com/7c54b6fd65fa0b4852e2ba7299a193b0957b7d44e558b37030b86bb476d5a86d/68747470733a2f2f692e6962622e636f2f4a7032625333362f4d617472696365732e706e67

**5.** Да се напише функция, която приема стринг **text** и символ **s** и връща матрица, за която е заделено точно количество памет, която съдържа всички думи от **text**, разделени с **s**.

**Пример:**

Вход:
```c++
Hello:my:name:is
:
```
Изход:
```c++
Hello
my
name
is
```

**6.** Да се напише функция, която приема масив от ребрата на ненасочен граф и връща матрица, за която е заделено точно количество памет, която представлява матрица на съседство на графа.

**Пример:**

Вход:
```c++
0 1
0 2
1 4
1 5
2 3
```

Изход:
```c++
0 1 1 0 0 0 
1 0 0 0 1 1 
1 0 0 1 0 0 
0 0 1 0 0 0 
0 1 0 0 0 0 
0 1 0 0 0 0 
```

**7.** Да се напише програма, която приема матрица и връща нова матрица, за която е заделено точно количество памет, има 2 пъти по-малко редове и първия ред представлява конкатенация на първия и последния,
втория - на втория и предпоследния и т.н. Ако редовете на подадената матрица са нечетен брой, последния ред остава непроменен.

**Пример:**

Вход:
```c++
0 1
0 2
1 4
1 5
2 3
```
Изход:
```c++
0 1 2 3
0 2 1 5

**4.** Да се напише функция, която приема стринг и връща нова матрица, за която е заделено точно количество памет, в която стрингът е записан зигзагообразно по следния начин:

**Пример:**

Вход:
```c++
PAYPALISHIRING
```
Изход:
```c++
P   A   H   N
A P L S I I G
Y   I   R
```
1 4
```
